# Backend Logic for Kindergarten System

## File Structure Overview

### Actions
```
src/actions/
├── admin/                      # Admin-related actions
├── kindergarten/              # Kindergarten management
├── auth/                      # Authentication actions
├── settings/                  # Settings management
├── parent/                    # Parent-related actions
├── dashboard/                 # Dashboard functionality
├── alert/                     # Alert system
├── student/                   # Student management
├── class/                     # Class management
├── event/                     # Event management
└── attendance/                # Attendance tracking
```

### API Routes
```
src/app/api/
├── kindergarten/              # Kindergarten-specific endpoints
│   ├── route.ts
│   └── [orgId]/
│       ├── dashboard/
│       │   ├── route.ts
│       │   └── stats/route.ts
│       ├── students/route.ts
│       ├── classes/route.ts
│       ├── events/route.ts
│       └── alerts/route.ts
├── students/                  # Student-specific endpoints
├── debug/                     # Debug endpoints
├── auth/                      # Authentication endpoints
└── test-firebase/            # Firebase test endpoints
```

### Hooks
```
src/hooks/
├── useAlerts.ts              # Alert management hooks
├── useDashboard.ts           # Dashboard data hooks
├── useAttendanceStats.ts     # Attendance statistics
├── useDashboardStats.ts      # Dashboard statistics
├── useArrivedStudents.ts     # Student arrival tracking
├── useStudents.ts            # Student management
├── useEvents.ts              # Event management
├── useSignUpForm.ts          # Registration form
├── use-action.ts             # Action handler utility
└── use-mobile.tsx            # Mobile device detection
```

### Library
```
src/lib/
├── utils/                    # Utility functions
├── firebase/                 # Firebase configurations
├── utils.ts                  # General utilities
├── s3-client.ts             # AWS S3 client
├── firebase-admin.ts         # Firebase Admin SDK
├── firebase.ts               # Firebase client SDK
├── polyfills.ts             # Polyfill configurations
├── create-safe-action.ts     # Action creator utility
└── db.ts                     # Database client
```

### Types
```
src/types/
├── alert.ts                  # Alert type definitions
└── dashboard.ts              # Dashboard type definitions
```

## Module Details

### 1. Authentication & Authorization
**Files**:
- **Actions**: `src/actions/auth/`
  - `index.ts`
  - `schema.ts`
  - `login.ts`
  - `register.ts`
- **API Routes**: `src/app/api/auth/`
  - `login/route.ts`
  - `register/route.ts`
  - `session/route.ts`
  - `user-type/route.ts`
  - `profile/route.ts`
- **Hooks**: 
  - `useSignUpForm.ts`

**Purpose**: Manage user authentication, session handling, and user type verification

**Functionality**:
- Login/Logout functionality
- Session management
- User type verification (Admin/Parent)
- Profile management

**Implementation**:

login/route.ts:
```typescript
// src/app/api/auth/login/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";

export async function POST(request: Request) {
  console.log("Login API route hit");
  
  try {
    const { firebaseId } = await request.json();
    console.log("Received firebaseId:", firebaseId);

    // First check for parent
    const parent = await db.parent.findUnique({
      where: { firebaseId },
    });

    if (parent) {
      console.log("Found parent user:", parent);
      return NextResponse.json({ 
        success: true,
        userType: "parent",
        userId: parent.id 
      });
    }

    // Then check for admin
    const admin = await db.admin.findUnique({
      where: { firebaseId },
      include: {
        kindergarten: true
      }
    });

    if (admin) {
      console.log("Found admin user:", admin);
      const needsSetup = !admin.kindergartenId;
      const redirectTo = needsSetup 
        ? "/setup" 
        : `/kindergarten/${admin.kindergartenId}/dashboard`;

      return NextResponse.json({
        success: true,
        userType: "kindergarten",
        needsSetup: needsSetup,
        userId: admin.id,
        redirectTo: redirectTo,
        data: {
          id: admin.id,
          name: admin.name,
          email: admin.email,
          role: admin.role,
          kindergartenId: admin.kindergartenId,
          needsSetup: needsSetup
        }
      });
    }

    console.log("No user found in database for firebaseId:", firebaseId);
    return NextResponse.json(
      { error: "User not found in database" },
      { status: 404 }
    );

  } catch (error) {
    console.error("Login API error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

session/route.ts:
```typescript
// src/app/api/auth/session/route.ts
import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { auth } from "@/lib/firebase-admin";

export async function POST(request: Request) {
  try {
    const { token } = await request.json();
    
    if (!token) {
      return NextResponse.json(
        { error: "Token is required" },
        { status: 400 }
      );
    }

    // Verify the token
    const decodedToken = await auth.verifyIdToken(token);

    // Create session cookie
    const expiresIn = 60 * 60 * 24 * 5 * 1000; // 5 days
    const sessionCookie = await auth.createSessionCookie(token, {
      expiresIn,
    });

    // Set cookie
    cookies().set("session", sessionCookie, {
      maxAge: expiresIn,
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Session API error:", error);
    return NextResponse.json(
      { error: "Failed to create session" },
      { status: 500 }
    );
  }
}

export async function DELETE() {
  try {
    cookies().delete("session");
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Delete session error:", error);
    return NextResponse.json(
      { error: "Failed to delete session" },
      { status: 500 }
    );
  }
}
```

user-type/route.ts:
```typescript
// src/app/api/auth/user-type/route.ts
import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { auth } from "@/lib/firebase-admin";
import { db } from "@/lib/db";

export async function GET() {
  try {
    const session = cookies().get("session")?.value;

    if (!session) {
      return NextResponse.json(
        { error: "No session found" },
        { status: 401 }
      );
    }

    const decodedToken = await auth.verifySessionCookie(session);
    const firebaseId = decodedToken.uid;

    // Check for parent
    const parent = await db.parent.findUnique({
      where: { firebaseId },
    });

    if (parent) {
      return NextResponse.json({
        userType: "parent",
        userId: parent.id,
      });
    }

    // Check for admin
    const admin = await db.admin.findUnique({
      where: { firebaseId },
    });

    if (admin) {
      return NextResponse.json({
        userType: "kindergarten",
        userId: admin.id,
        needsSetup: !admin.kindergartenId,
      });
    }

    return NextResponse.json(
      { error: "User not found" },
      { status: 404 }
    );
  } catch (error) {
    console.error("User type API error:", error);
    return NextResponse.json(
      { error: "Failed to get user type" },
      { status: 500 }
    );
  }
}
```

useSignUpForm.ts:
```typescript
// src/hooks/useSignUpForm.ts
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { SignUpSchema, SignUpSchemaType } from "@/actions/auth/schema";

export function useSignUpForm() {
  return useForm<SignUpSchemaType>({
    resolver: zodResolver(SignUpSchema),
    defaultValues: {
      name: "",
      email: "",
      password: "",
      confirmPassword: "",
    },
  });
}
```

[Continue with next module...]

### 2. Kindergarten Management
**Files**:
- **Actions**: `src/actions/kindergarten/`
  - `index.ts`
  - `schema.ts`
  - `setup.ts`
- **API Routes**: `src/app/api/kindergarten/`
  - `route.ts`
  - `[orgId]/route.ts`
- **Hooks**: 
  - `useKindergarten.ts`

**Purpose**: Manage kindergarten setup, configuration, and operations

**Functionality**:
- Kindergarten setup and configuration
- Operating hours management
- Alert threshold settings
- Join/Leave kindergarten functionality

**Implementation**:

schema.ts:
```typescript
// src/actions/kindergarten/schema.ts
import { z } from "zod";
import { DayOfWeek } from "@prisma/client";

export const SetupSchema = z.object({
  adminId: z.string().min(1, "Admin ID is required"),
  name: z.string().min(1, "Name is required"),
  address: z.string().min(1, "Address is required"),
  operatingHours: z.array(z.object({
    dayOfWeek: z.nativeEnum(DayOfWeek),
    isOpen: z.boolean(),
    startTime: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),
    endTime: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/)
  })).min(1, "At least one operating day is required"),
  messageAlertThreshold: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),
  callAlertThreshold: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/)
});

export const KindergartenSettingsSchema = z.object({
  id: z.string().min(1, "ID is required"),
  name: z.string().min(1, "Name is required"),
  address: z.string().min(1, "Address is required"),
  operatingHours: z.array(z.object({
    dayOfWeek: z.nativeEnum(DayOfWeek),
    startTime: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),
    endTime: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/)
  })),
  messageAlertThreshold: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),
  callAlertThreshold: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/)
});

export const KindergartenJoinSchema = z.object({
  adminId: z.string().min(1, "Admin ID is required"),
  kindergartenId: z.string().min(1, "Kindergarten ID is required")
});

export type KindergartenSettingsSchemaType = z.infer<typeof KindergartenSettingsSchema>;
```

index.ts:
```typescript
// src/actions/kindergarten/index.ts
"use server";

import { db } from "@/lib/db";
import { 
  KindergartenSettingsSchema, 
  KindergartenSettingsSchemaType,
  KindergartenJoinSchema,
  SetupSchema
} from "./schema";
import { createSafeAction } from "@/lib/create-safe-action";
import { z } from "zod";
import { DayOfWeek } from "@prisma/client";

// Get kindergarten details
const getKindergartenHandler = async (id: string) => {
  try {
    const kindergarten = await db.kindergarten.findUnique({
      where: { id },
      include: {
        operatingHours: {
          orderBy: {
            dayOfWeek: 'asc'
          }
        }
      }
    });

    if (!kindergarten) {
      return { error: "Kindergarten not found" };
    }

    return { data: kindergarten };
  } catch (error) {
    return { error: "Failed to fetch kindergarten details" };
  }
};

// Update kindergarten settings
const updateKindergartenHandler = async (data: KindergartenSettingsSchemaType) => {
  try {
    const updatedKindergarten = await db.kindergarten.update({
      where: { id: data.id },
      data: {
        name: data.name,
        address: data.address,
        messageAlertThreshold: new Date(`1970-01-01T${data.messageAlertThreshold}`),
        callAlertThreshold: new Date(`1970-01-01T${data.callAlertThreshold}`),
      },
    });

    await db.operatingHours.deleteMany({
      where: { kindergartenId: data.id }
    });

    await db.operatingHours.createMany({
      data: data.operatingHours.map(oh => ({
        kindergartenId: data.id,
        dayOfWeek: oh.dayOfWeek,
        startTime: new Date(`1970-01-01T${oh.startTime}`),
        endTime: new Date(`1970-01-01T${oh.endTime}`)
      }))
    });

    return { data: updatedKindergarten };
  } catch (error) {
    console.error("Update error:", error);
    return { error: "Failed to update kindergarten settings" };
  }
};

// Get available kindergartens
const getAvailableKindergartensHandler = async () => {
  try {
    const kindergartens = await db.kindergarten.findMany({
      select: {
        id: true,
        name: true, 
        address: true,
        _count: {
          select: {
            classes: true,
            admins: true
          }
        }
      },
      orderBy: {
        name: 'asc'
      }
    });
    
    return { data: kindergartens };
  } catch (error) {
    return { error: "Failed to fetch kindergartens" };
  }
};

// Join kindergarten
const joinKindergartenHandler = async (data: z.infer<typeof KindergartenJoinSchema>) => {
  try {
    const existingAdmin = await db.admin.findUnique({
      where: { id: data.adminId },
      include: { kindergarten: true }
    });

    if (existingAdmin?.kindergartenId) {
      return { error: "You are already associated with a kindergarten" };
    }

    const kindergarten = await db.kindergarten.findUnique({
      where: { id: data.kindergartenId }
    });

    if (!kindergarten) {
      return { error: "Kindergarten not found" };
    }

    const updatedAdmin = await db.admin.update({
      where: { id: data.adminId },
      data: {
        kindergartenId: data.kindergartenId,
        role: "ADMIN"
      },
      include: {
        kindergarten: true
      }
    });

    return { data: updatedAdmin };
  } catch (error) {
    return { error: "Failed to join kindergarten" };
  }
};

// Export handlers with safe action wrappers
export const getKindergarten = getKindergartenHandler;
export const updateKindergarten = createSafeAction(
  KindergartenSettingsSchema,
  updateKindergartenHandler  
);
export const completeSetup = createSafeAction(
  SetupSchema,
  completeSetupHandler
);

export async function getAvailableKindergartens() {
  return getAvailableKindergartensHandler();
}

export async function joinKindergarten(
  data: z.infer<typeof KindergartenJoinSchema>
) {
  const validation = KindergartenJoinSchema.safeParse(data);
  
  if (!validation.success) {
    return { error: "Invalid data provided" };
  }

  return joinKindergartenHandler(data);
}
```

setup.ts:
```typescript
// src/actions/kindergarten/setup.ts
"use server"

import { db } from "@/lib/db";
import { z } from "zod";
import { createSafeAction } from "@/lib/create-safe-action";
import { SetupSchema } from "./schema";

const handler = async (data: z.infer<typeof SetupSchema>) => {
  console.log("Setup handler called with data:", data);
  
  try {
    // Check if the kindergarten already exists
    const existingKindergarten = await db.kindergarten.findFirst({
      where: {
        name: data.name
      }
    });

    if (existingKindergarten) {
      // Check if this admin is already associated with it
      const admin = await db.admin.findUnique({
          where: { id: data.adminId},
          include: { kindergarten: true} 
      });

      if (admin?.kindergartenId === existingKindergarten.id) {
          return { data: existingKindergarten}
      }

      return { error: "Kindergarten already exists"} 
    }
      
    console.log("Starting schema validation");
    // Explicitly validate with schema
    const validatedData = SetupSchema.parse(data);
    console.log("Schema validation passed:", validatedData);

    console.log("Starting kindergarten creation");
    const kindergarten = await db.kindergarten.create({
      data: {
        name: validatedData.name,
        address: validatedData.address,
        messageAlertThreshold: new Date(`1970-01-01T${validatedData.messageAlertThreshold}`),
        callAlertThreshold: new Date(`1970-01-01T${validatedData.callAlertThreshold}`),
        operatingHours: {
          create: validatedData.operatingHours
            .filter(oh => oh.isOpen)
            .map(oh => ({
              dayOfWeek: oh.dayOfWeek,
              startTime: new Date(`1970-01-01T${oh.startTime}`),
              endTime: new Date(`1970-01-01T${oh.endTime}`)
            }))
        }
      }
    });
    console.log("Kindergarten created:", kindergarten);

    console.log("Updating admin");
    const updatedAdmin = await db.admin.update({
      where: { id: validatedData.adminId },
      data: {
        kindergartenId: kindergarten.id,
        role: "SUPER_ADMIN"
      }
    });
    console.log("Admin updated:", updatedAdmin);

    return { data: kindergarten };
  } catch (error) {
    console.error("Setup handler error:", error);
    if (error instanceof z.ZodError) {
      console.error("Validation error:", error.errors);
      return { fieldErrors: error.flatten().fieldErrors };
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      return { error: "A kindergarten with this name already exists" };
    }
    return { error: error instanceof Error ? error.message : "Failed to complete setup" };
  }
};

export const completeSetup = createSafeAction(SetupSchema, handler);
```

[Continue with next module...]

### 3. Dashboard
**Files**:
- **Actions**: `src/actions/dashboard/`
  - `index.ts`
  - `schema.ts`
- **API Routes**: `src/app/api/kindergarten/[orgId]/dashboard/`
  - `route.ts`
  - `stats/route.ts`
- **Hooks**: 
  - `useDashboard.ts`
  - `useDashboardStats.ts`
- **Types**:
  - `dashboard.ts`

**Purpose**: Provide real-time overview of kindergarten operations and statistics

**Functionality**:
- Display key statistics (students, attendance, etc.)
- Class utilization tracking
- Attendance monitoring
- Event and alert summaries

**Implementation**:

types/dashboard.ts:
```typescript
// types/dashboard.ts
import { AlertLog, AttendanceStatus } from "@prisma/client";

export interface DashboardStats {
  totalStudents: number;
  presentToday: number;
  lateToday: number;
  absentNoReason: number;
}

export interface ClassUtilization {
  id: string;
  name: string;
  capacity: number;
  studentCount: number;
  utilizationRate: number;
}

export interface AttendanceChartData {
  month: string;
  rate: number;
}

export interface ArrivedStudent {
  id: string;
  name: string;
  class: string;
  arrivalTime: Date;
  status: AttendanceStatus;
}

export interface DashboardData {
  stats: DashboardStats;
  classUtilization: ClassUtilization[];
  attendanceChart: AttendanceChartData[];
  arrivedStudents: ArrivedStudent[];
  events: Event[];
  alerts: AlertLog[];
}
```

actions/dashboard/index.ts:
```typescript
// src/actions/dashboard/index.ts
"use server";

import { db } from "@/lib/db";

export const getDashboardStats = async (kindergartenId: string) => {
  try {
    const [
      totalStudents,
      totalClasses,
      upcomingEvents,
      unreadAlerts,
      classUtilization
    ] = await Promise.all([
      // Get total students
      db.student.count({
        where: {
          class: {
            kindergartenId
          }
        }
      }),
      // Get total classes
      db.class.count({
        where: { kindergartenId }
      }),
      // Get upcoming events
      db.event.findMany({
        where: {
          kindergartenId,
          startDate: {
            gte: new Date()
          }
        },
        take: 5,
        include: {
          attendees: true
        }
      }),
      // Get unread alerts
      db.alert.findMany({
        where: {
          kindergartenId,
          isRead: false
        },
        take: 5
      }),
      // Get class utilization
      db.class.findMany({
        where: { kindergartenId },
        include: {
          students: true,
        }
      })
    ]);

    // Calculate overall utilization
    const totalCapacity = classUtilization.reduce((acc, curr) => acc + (curr.capacity || 0), 0);
    const totalEnrolled = classUtilization.reduce((acc, curr) => acc + curr.students.length, 0);
    const overallUtilization = totalCapacity > 0 ? totalEnrolled / totalCapacity : 0;

    return {
      data: {
        totalStudents,
        totalClasses,
        upcomingEvents,
        unreadAlerts,
        classUtilization: classUtilization.map(c => ({
          id: c.id,
          name: c.name,
          capacity: c.capacity || 0,
          studentCount: c.students.length,
          utilizationRate: c.capacity ? (c.students.length / c.capacity) * 100 : 0
        })),
        overallUtilization
      }
    };
  } catch (error) {
    console.error("[GET_DASHBOARD_STATS]", error);
    return { error: "Failed to fetch dashboard stats" };
  }
}
```

hooks/useDashboard.ts:
```typescript
// hooks/useDashboard.ts
import { useQuery } from "@tanstack/react-query";

export function useDashboard(kindergartenId: string) {
  return useQuery({
    queryKey: ['dashboard', kindergartenId],
    queryFn: async () => {
      const response = await fetch(`/api/kindergarten/${kindergartenId}/dashboard`);
      if (!response.ok) throw new Error('Failed to fetch dashboard data');
      return response.json();
    },
    refetchInterval: 30000 // Refetch every 30 seconds to keep data fresh
  });
}
```

hooks/useDashboardStats.ts:
```typescript
// hooks/useDashboardStats.ts
import { useQuery } from "@tanstack/react-query";

export interface DashboardStats {
  totalStudents: number;
  totalClasses: number;
  overallUtilization: number;
  classUtilization: Array<{
    id: string;
    name: string;
    capacity: number;
    studentCount: number;
    utilizationRate: number;
  }>;
  currentDayStats: {
    present: number;
    late: number;
    absent: number;
    absentNoReason: number;
  };
}

export function useDashboardStats(kindergartenId: string) {
  return useQuery({
    queryKey: ['dashboard', 'stats', kindergartenId],
    queryFn: async () => {
      const response = await fetch(`/api/kindergarten/${kindergartenId}/dashboard/stats`);
      if (!response.ok) throw new Error('Failed to fetch dashboard stats');
      return response.json();
    }
  });
}
```

[Continue with next module...]

### 4. Student Management
**Files**:
- **Actions**: `src/actions/student/`
  - `index.ts`
  - `schema.ts`
- **API Routes**: `src/app/api/kindergarten/[orgId]/students/`
  - `route.ts`
  - `[studentId]/route.ts`
- **Hooks**: 
  - `useStudents.ts`
- **Types**:
  - `student.ts`

**Purpose**: Manage student records, attendance, and face recognition data

**Functionality**:
- Student registration and profile management
- Face recognition data storage
- Attendance tracking
- Performance monitoring
- Parent-student association

**Implementation**:

actions/student/index.ts:
```typescript
// src/actions/student/index.ts
"use server";

import { db } from "@/lib/db";
import { StudentSchema, StudentSchemaType } from "./schema";
import { createSafeAction } from "@/lib/create-safe-action";
import { z } from "zod";

// Get all students for a kindergarten
export const getStudents = async (kindergartenId: string) => {
  try {
    const students = await db.student.findMany({
      where: {
        class: {
          kindergartenId
        }
      },
      include: {
        class: {
          select: {
            id: true,
            name: true
          }
        },
        attendance: {
          orderBy: {
            date: 'desc'
          },
          take: 30 // Last 30 days for attendance calculation
        }
      },
      orderBy: {
        fullName: 'asc'
      }
    });

    // Calculate attendance performance
    const studentsWithPerformance = students.map(student => {
      const totalDays = student.attendance.length;
      const presentDays = student.attendance.filter(
        a => a.status === 'ON_TIME' || a.status === 'LATE'
      ).length;
      const attendancePerformance = totalDays > 0 
        ? ((presentDays / totalDays) * 100).toFixed(1) + '%'
        : 'N/A';

      if (!student.class) {
        throw new Error(`Student ${student.id} has no assigned class`);
      }

      return {
        id: student.id,
        name: student.fullName,
        age: student.age,
        class: student.class.name,
        daysAbsent: student.daysAbsent,
        attendancePerformance
      };
    });

    return { data: studentsWithPerformance };
  } catch (error) {
    console.error("[GET_STUDENTS]", error);
    return { error: "Failed to fetch students" };
  }
};

// Get a single student
export const getStudent = async (studentId: string) => {
  try {
    const student = await db.student.findUnique({
      where: { id: studentId },
      include: {
        class: true,
        attendance: {
          orderBy: {
            date: 'desc'
          },
          take: 10,
        },
        alertLogs: {
          orderBy: {
            alertTime: 'desc'
          },
          take: 5,
        },
      },
    });

    if (!student) {
      return { error: "Student not found" };
    }

    return { data: student };
  } catch (error) {
    console.error("[GET_STUDENT]", error);
    return { error: "Failed to fetch student" };
  }
};

// Create a student
const createStudentHandler = async (data: StudentSchemaType) => {
  try {
    const student = await db.student.create({
      data: {
        fullName: data.fullName,
        age: data.age,
        classId: data.classId,
        parentId: data.parentId,
        faceImageFront: data.faceImageFront,
        faceImageLeft: data.faceImageLeft,
        faceImageRight: data.faceImageRight,
        faceImageTiltUp: data.faceImageTiltUp,
        faceImageTiltDown: data.faceImageTiltDown,
      },
      include: {
        class: true
      }
    });

    return { data: student };
  } catch (error) {
    console.error("[CREATE_STUDENT]", error);
    return { error: "Failed to create student" };
  }
};

// Update a student
const updateStudentHandler = async (data: StudentSchemaType & { id: string }) => {
  try {
    const student = await db.student.update({
      where: { id: data.id },
      data: {
        fullName: data.fullName,
        age: data.age,
        classId: data.classId,
        faceImageFront: data.faceImageFront,
        faceImageLeft: data.faceImageLeft,
        faceImageRight: data.faceImageRight,
        faceImageTiltUp: data.faceImageTiltUp,
        faceImageTiltDown: data.faceImageTiltDown,
      },
      include: {
        class: true
      }
    });

    return { data: student };
  } catch (error) {
    console.error("[UPDATE_STUDENT]", error);
    return { error: "Failed to update student" };
  }
};

export const createStudent = createSafeAction(StudentSchema, createStudentHandler);
export const updateStudent = createSafeAction(
  StudentSchema.extend({ id: z.string() }), 
  updateStudentHandler
);
```

hooks/useStudents.ts:
```typescript
// hooks/useStudents.ts
import { useQuery } from "@tanstack/react-query";
import { Student } from "@prisma/client";

export function useStudents(kindergartenId: string) {
  return useQuery({
    queryKey: ['students', kindergartenId],
    queryFn: async () => {
      const response = await fetch(`/api/kindergarten/${kindergartenId}/students`);
      if (!response.ok) throw new Error('Failed to fetch students');
      return response.json();
    }
  });
}

export function useStudent(studentId: string) {
  return useQuery({
    queryKey: ['student', studentId],
    queryFn: async () => {
      const response = await fetch(`/api/students/${studentId}`);
      if (!response.ok) throw new Error('Failed to fetch student');
      return response.json();
    }
  });
}
```

actions/parent/add-child.ts:
```typescript
// src/actions/parent/add-child.ts
"use server";

import { db } from "@/lib/db";
import { AddChildSchema } from "./schema";
import { createSafeAction } from "@/lib/create-safe-action";

const handler = async (data: any) => {
  const { fullName, dateOfBirth, parentId, classId, faceImages } = data;

  try {
    const student = await db.student.create({
      data: {
        fullName,
        age: new Date().getFullYear() - dateOfBirth.getFullYear(),
        classId,
        parentId,
        faceImageFront: faceImages.front,
        faceImageLeft: faceImages.left,
        faceImageRight: faceImages.right,
        faceImageTiltUp: faceImages.tiltUp,
        faceImageTiltDown: faceImages.tiltDown,
      },
    });

    return { data: student };
  } catch (error) {
    console.error("[ADD_CHILD_ERROR]:", error);
    return { error: "Failed to create student" };
  }
};

export const addChild = createSafeAction(AddChildSchema, handler);
```

[Continue with next module...]

### 5. Class Management
**Files**:
- **Actions**: `src/actions/class/`
  - `index.ts`
  - `schema.ts`
- **API Routes**: `src/app/api/kindergarten/[orgId]/classes/`
  - `route.ts`
- **Hooks**: 
  - `useClasses.ts`
- **Types**:
  - `class.ts`

**Purpose**: Manage classroom operations, including creation, updates, and student assignments

**Functionality**:
- Class creation and updates
- Student assignment
- Capacity management
- Class utilization tracking

**Implementation**:

actions/class/index.ts:
```typescript
// src/actions/class/index.ts
"use server";

import { db } from "@/lib/db";
import { ClassSchema, ClassSchemaType } from "./schema";
import { createSafeAction } from "@/lib/create-safe-action";
import { z } from "zod";

// Get all classes for a kindergarten
export const getClasses = async (kindergartenId: string) => {
  try {
    const classes = await db.class.findMany({
      where: {
        kindergartenId
      },
      include: {
        _count: {
          select: {
            students: true
          }
        }
      },
      orderBy: {
        name: 'asc'
      }
    });

    const classesWithDetails = classes.map(class_ => ({
      id: class_.id,
      name: class_.name,
      capacity: class_.capacity,
      studentCount: class_._count.students
    }));

    return { data: classesWithDetails };
  } catch (error) {
    console.error("[GET_CLASSES]", error);
    return { error: "Failed to fetch classes" };
  }
};

// Get a single class
export const getClass = async (classId: string) => {
  try {
    const class_ = await db.class.findUnique({
      where: { id: classId },
      include: {
        _count: {
          select: {
            students: true
          }
        }
      }
    });

    if (!class_) {
      return { error: "Class not found" };
    }

    return { 
      data: {
        ...class_,
        studentCount: class_._count.students
      }
    };
  } catch (error) {
    console.error("[GET_CLASS]", error);
    return { error: "Failed to fetch class" };
  }
};

// Create a class
const createClassHandler = async (data: ClassSchemaType) => {
  try {
    const class_ = await db.class.create({
      data: {
        name: data.name,
        capacity: data.capacity,
        kindergartenId: data.kindergartenId
      }
    });

    return { data: class_ };
  } catch (error) {
    console.error("[CREATE_CLASS]", error);
    return { error: "Failed to create class" };
  }
};

// Update a class
const updateClassHandler = async (data: ClassSchemaType & { id: string }) => {
  try {
    console.log("Updating class with data:", data);  // Debug log
    
    // Check if updating would exceed capacity
    const currentStudents = await db.student.count({
      where: { classId: data.id }
    });

    if (currentStudents > data.capacity) {
      return { 
        error: `Cannot reduce capacity below current student count (${currentStudents} students)` 
      };
    }

    const class_ = await db.class.update({
      where: { id: data.id },
      data: {
        name: data.name,
        capacity: data.capacity
      }
    });

    console.log("Updated class:", class_);  // Debug log
    return { data: class_ };
  } catch (error) {
    console.error("[UPDATE_CLASS]", error);
    return { error: "Failed to update class" };
  }
};

// Delete a class
export const deleteClass = async (classId: string) => {
  try {
    // Check if class has students
    const studentCount = await db.student.count({
      where: { classId }
    });

    if (studentCount > 0) {
      return { 
        error: "Cannot delete class with enrolled students" 
      };
    }

    await db.class.delete({
      where: { id: classId }
    });

    return { data: { success: true } };
  } catch (error) {
    console.error("[DELETE_CLASS]", error);
    return { error: "Failed to delete class" };
  }
};

export const createClass = createSafeAction(ClassSchema, createClassHandler);
export const updateClass = createSafeAction(
  ClassSchema.extend({ id: z.string() }), 
  updateClassHandler
);
```

hooks/useClasses.ts:
```typescript
// hooks/useClasses.ts
import { useQuery } from "@tanstack/react-query";

export interface Class {
  id: string;
  name: string;
  capacity: number;
  _count: {
    students: number;
  }
}

export function useClasses(kindergartenId: string) {
  return useQuery({
    queryKey: ['classes', kindergartenId],
    queryFn: async () => {
      const response = await fetch(`/api/kindergarten/${kindergartenId}/classes`);
      if (!response.ok) throw new Error('Failed to fetch classes');
      
      const data = await response.json();
      return data.data;
    }
  });
}

export function useClass(classId: string) {
  return useQuery({
    queryKey: ['class', classId],
    queryFn: async () => {
      const response = await fetch(`/api/classes/${classId}`);
      if (!response.ok) throw new Error('Failed to fetch class');
      return response.json();
    }
  });
}
```

[Continue with next module...]

### 6. Event Management
**Files**:
- **Actions**: `src/actions/event/`
  - `index.ts`
  - `schema.ts`
- **API Routes**: `src/app/api/kindergarten/[orgId]/events/`
  - `route.ts`
  - `debug/events/route.ts`
- **Hooks**: 
  - `useEvents.ts`
- **Types**:
  - `event.ts`

**Purpose**: Manage kindergarten events, including creation, scheduling, and attendance tracking

**Functionality**:
- Event creation and scheduling
- Target audience management
- Event attendance tracking
- Past and upcoming event organization
- Event notifications

**Implementation**:

actions/event/schema.ts:
```typescript
import { z } from "zod";
import { EventType, UserType } from "@prisma/client";

export const EventSchema = z.object({
    id: z.string().optional(),
    title: z.string().min(1, "Title is required"),
    description: z.string().min(1, "Description is required"),
    startDate: z.date(),
    endDate: z.date(),
    location: z.string().min(1, "Location is required"),
    type: z.nativeEnum(EventType),
    kindergartenId: z.string().min(1, "Kindergarten ID is required"),
    targetAudience: z.nativeEnum(UserType).array(),
    isAllDay: z.boolean(),
    createdAt: z.date().optional(),
    updatedAt: z.date().optional(),
});

export const EventWithAttendeesSchema = EventSchema.extend({
    attendees: z.array(z.object({
        id: z.string(),
        name: z.string(),
        type: z.nativeEnum(UserType),
        status: z.enum(["PENDING", "ACCEPTED", "DECLINED"]),
    })),
});

export type EventSchemaType = z.infer<typeof EventSchema>;
export type EventWithAttendeesSchemaType = z.infer<typeof EventWithAttendeesSchema>;
```

actions/event/index.ts:
```typescript
"use server";

import { db } from "@/lib/db";
import { EventSchema, EventSchemaType, EventWithAttendeesSchema } from "./schema";
import { createSafeAction } from "@/lib/create-safe-action";
import { z } from "zod";
import { UserType } from "@prisma/client";

// Get all events for a kindergarten
export const getEvents = async (kindergartenId: string, userType: UserType) => {
  try {
    console.log("Fetching events for kindergarten:", kindergartenId);
    const events = await db.event.findMany({
      where: {
        kindergartenId,
        targetAudience: {
          hasSome: [userType, "ALL"]
        },
        endDate: {
          gte: new Date() // Only show current and future events
        }
      },
      include: {
        attendees: true
      },
      orderBy: {
        startDate: 'asc'
      }
    });

    return { data: events };
  } catch (error) {
    console.error("[GET_EVENTS]", error);
    return { error: "Failed to fetch events" };
  }
};

// Get upcoming events
export const getUpcomingEvents = async (kindergartenId: string, userType: UserType, limit = 5) => {
  try {
    const events = await db.event.findMany({
      where: {
        kindergartenId,
        targetAudience: {
          hasSome: [userType, "ALL"]
        },
        startDate: {
          gte: new Date()
        }
      },
      include: {
        attendees: true
      },
      orderBy: {
        startDate: 'asc'
      },
      take: limit
    });

    return { data: events };
  } catch (error) {
    console.error("[GET_UPCOMING_EVENTS]", error);
    return { error: "Failed to fetch upcoming events" };
  }
};

// Create an event
const createEventHandler = async (data: EventSchemaType) => {
  try {
    const event = await db.event.create({
      data: {
        title: data.title,
        description: data.description,
        startDate: data.startDate,
        endDate: data.endDate,
        location: data.location,
        type: data.type,
        kindergartenId: data.kindergartenId,
        targetAudience: data.targetAudience,
        isAllDay: data.isAllDay,
      }
    });

    return { data: event };
  } catch (error) {
    console.error("[CREATE_EVENT]", error);
    return { error: "Failed to create event" };
  }
};

// Update an event
const updateEventHandler = async (data: EventSchemaType & { id: string }) => {
  try {
    const event = await db.event.update({
      where: { id: data.id },
      data: {
        title: data.title,
        description: data.description,
        startDate: data.startDate,
        endDate: data.endDate,
        location: data.location,
        type: data.type,
        targetAudience: data.targetAudience,
        isAllDay: data.isAllDay,
      }
    });

    return { data: event };
  } catch (error) {
    console.error("[UPDATE_EVENT]", error);
    return { error: "Failed to update event" };
  }
};

// Delete an event
export const deleteEvent = async (eventId: string) => {
  try {
    await db.event.delete({
      where: { id: eventId }
    });

    return { data: { success: true } };
  } catch (error) {
    console.error("[DELETE_EVENT]", error);
    return { error: "Failed to delete event" };
  }
};

// Update attendee status
export const updateAttendeeStatus = async (
  eventId: string,
  attendeeId: string,
  status: "PENDING" | "ACCEPTED" | "DECLINED"
) => {
  try {
    const attendee = await db.attendee.update({
      where: { 
        id: attendeeId,
        eventId: eventId
      },
      data: { status }
    });

    return { data: attendee };
  } catch (error) {
    console.error("[UPDATE_ATTENDEE_STATUS]", error);
    return { error: "Failed to update attendee status" };
  }
};

// Add attendees to an event
export const addEventAttendees = async (
  eventId: string,
  attendees: { name: string; type: UserType }[]
) => {
  try {
    const event = await db.event.update({
      where: { id: eventId },
      data: {
        attendees: {
          createMany: {
            data: attendees.map(attendee => ({
              name: attendee.name,
              type: attendee.type,
              status: "PENDING"
            }))
          }
        }
      },
      include: {
        attendees: true
      }
    });

    return { data: event };
  } catch (error) {
    console.error("[ADD_EVENT_ATTENDEES]", error);
    return { error: "Failed to add attendees" };
  }
};

export const createEvent = createSafeAction(EventSchema, createEventHandler);
export const updateEvent = createSafeAction(
  EventSchema.extend({ id: z.string() }),
  updateEventHandler
);
```

hooks/useEvents.ts:
```typescript
// hooks/useEvents.ts
import { EventSchemaType } from "@/actions/event/schema";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { UserType } from "@prisma/client";

export interface Event {
  id: string;
  title: string;
  description: string;
  startDate: Date | string;
  location: string;
  targetAudience: UserType[];
  classes: {
    class: {
      id: string;
      name: string;
    }
  }[];
}

export interface EventsData {
  upcoming: Event[];
  past: Event[];
}

// Add this new hook for creating events
export function useCreateEvent() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: EventSchemaType) => {
      const response = await fetch('/api/kindergarten/events', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        throw new Error('Failed to create event');
      }

      return response.json();
    },
    onSuccess: () => {
      // Invalidate events query to refetch the list
      queryClient.invalidateQueries({ queryKey: ['events'] });
    },
  });
}

export function useEvents(kindergartenId: string) {
  return useQuery<EventsData>({
    queryKey: ['events', kindergartenId],
    queryFn: async () => {
      console.log("Fetching events for kindergarten:", kindergartenId);
      
      const response = await fetch(`/api/kindergarten/${kindergartenId}/events`);
      if (!response.ok) {
        console.error("Failed to fetch events:", await response.text());
        throw new Error('Failed to fetch events');
      }
      
      const data = await response.json();
      console.log("Raw events data:", data);
      
      const now = new Date();
      const events = data.data || [];
      
      // Sort into upcoming and past events
      const sorted = {
        upcoming: events.filter((e: Event) => {
          const eventDate = new Date(e.startDate);
          console.log(`Event ${e.title}:`, {
            date: eventDate,
            isUpcoming: eventDate >= now
          });
          return eventDate >= now;
        }),
        past: events.filter((e: Event) => new Date(e.startDate) < now)
      };

      console.log("Sorted events:", sorted);
      return sorted;
    },
    staleTime: 1000 * 60, // Cache for 1 minute
  });
}
```

[Continue with next module...]

### 7. Alert Management
**Files**:
- **Actions**: `src/actions/alert/`
  - `index.ts`
  - `schema.ts`
  - `notification.ts`
- **API Routes**: `src/app/api/kindergarten/[orgId]/alerts/`
  - `route.ts`
- **Hooks**: 
  - `useAlerts.ts`
- **Types**:
  - `alert.ts`

**Purpose**: Manage attendance alerts and notifications for late arrivals and absences

**Functionality**:
- Alert creation and management
- Parent response tracking
- Alert history logging
- Alert status monitoring
- Notification thresholds

**Implementation**:

types/alert.ts:
```typescript
// lib/types/alert.ts
import { AlertType, ParentAction } from "@prisma/client";

export interface AlertStudent {
  id: string;
  name: string;
  class: string;
  attendancePerformance: string;
  parentAction: ParentAction;
  alertStatus: AlertType;
  reason?: string;
}

export interface AlertsData {
  responded: AlertStudent[];
  awaiting: AlertStudent[];
}
```

actions/alert/schema.ts:
```typescript
import { z } from "zod";
import { AlertType, UserType } from "@prisma/client";

export const AlertSchema = z.object({
  id: z.string().optional(),
  title: z.string().min(1, "Title is required"),
  message: z.string().min(1, "Message is required"),
  type: z.nativeEnum(AlertType),
  kindergartenId: z.string().min(1, "Kindergarten ID is required"),
  targetUserType: z.nativeEnum(UserType),
  isRead: z.boolean(),
  expiresAt: z.date().optional(),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
});

export type AlertSchemaType = z.infer<typeof AlertSchema>;
```

actions/alert/index.ts:
```typescript
"use server";

import { db } from "@/lib/db";
import { AlertSchema, AlertSchemaType } from "./schema";
import { createSafeAction } from "@/lib/create-safe-action";
import { UserType } from "@prisma/client";

// Get all alerts for a kindergarten
export const getAlerts = async (kindergartenId: string, userType: UserType) => {
  try {
    const alerts = await db.alert.findMany({
      where: {
        kindergartenId,
        AND: [
          {
            OR: [
              { targetUserType: userType },
              { targetUserType: "ALL" }
            ]
          },
          {
            OR: [
              { expiresAt: { gt: new Date() } },
              { expiresAt: null }
            ]
          }
        ]
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    return { data: alerts };
  } catch (error) {
    console.error("[GET_ALERTS]", error);
    return { error: "Failed to fetch alerts" };
  }
};

// Create an alert
const createAlertHandler = async (data: AlertSchemaType) => {
  try {
    const alert = await db.alert.create({
      data: {
        title: data.title,
        message: data.message,
        type: data.type,
        kindergartenId: data.kindergartenId,
        targetUserType: data.targetUserType,
        expiresAt: data.expiresAt,
      }
    });

    return { data: alert };
  } catch (error) {
    console.error("[CREATE_ALERT]", error);
    return { error: "Failed to create alert" };
  }
};

// Mark alert as read
export const markAlertAsRead = async (alertId: string) => {
  try {
    const alert = await db.alert.update({
      where: { id: alertId },
      data: { isRead: true }
    });

    return { data: alert };
  } catch (error) {
    console.error("[MARK_ALERT_READ]", error);
    return { error: "Failed to mark alert as read" };
  }
};

// Delete an alert
export const deleteAlert = async (alertId: string) => {
  try {
    await db.alert.delete({
      where: { id: alertId }
    });

    return { data: { success: true } };
  } catch (error) {
    console.error("[DELETE_ALERT]", error);
    return { error: "Failed to delete alert" };
  }
};

// Get unread alerts count
export const getUnreadAlertsCount = async (kindergartenId: string, userType: UserType) => {
  try {
    const count = await db.alert.count({
      where: {
        kindergartenId,
        isRead: false,
        AND: [
          {
            OR: [
              { targetUserType: userType },
              { targetUserType: "ALL" }
            ]
          },
          {
            OR: [
              { expiresAt: { gt: new Date() } },
              { expiresAt: null }
            ]
          }
        ]
      }
    });

    return { data: count };
  } catch (error) {
    console.error("[GET_UNREAD_ALERTS_COUNT]", error);
    return { error: "Failed to get unread alerts count" };
  }
};

export const createAlert = createSafeAction(AlertSchema, createAlertHandler);
```

hooks/useAlerts.ts:
```typescript
// hooks/useAlerts.ts
import { useQuery } from "@tanstack/react-query";
import { AlertsData } from "@/types/alert";

export function useAlerts(kindergartenId: string) {
  return useQuery<AlertsData>({  
    queryKey: ['alerts', kindergartenId],
    queryFn: async () => {
      const response = await fetch(`/api/kindergarten/${kindergartenId}/alerts`);
      if (!response.ok) throw new Error('Failed to fetch alerts');
      const data = await response.json();
      return data.data;
    }
  });
}
```

api/kindergarten/[orgId]/alerts/route.ts:
```typescript
// app/api/kindergarten/[orgId]/alerts/route.ts
import { db } from "@/lib/db";
import { NextResponse } from "next/server";

export async function GET(
  req: Request,
  { params }: { params: { orgId: string } }
) {
  try {
    const alerts = await db.alertLog.findMany({
      where: {
        student: {
          class: {
            kindergartenId: params.orgId
          }
        }
      },
      include: {
        student: {
          include: {
            class: true,
            attendance: {
              orderBy: {
                date: 'desc'
              },
              take: 30
            }
          }
        }
      },
      orderBy: {
        alertTime: 'desc'
      }
    });

    // Process alerts into responded and awaiting
    const processedAlerts = alerts.map(alert => {
      const student = alert.student;
      const totalDays = student.attendance.length;
      const presentDays = student.attendance.filter(
        a => a.status === 'ON_TIME' || a.status === 'LATE'
      ).length;
      const attendancePerformance = totalDays > 0 
        ? `${((presentDays / totalDays) * 100).toFixed(1)}%`
        : 'N/A';

      return {
        id: alert.id,
        name: student.fullName,
        class: student.class?.name || 'Unassigned',
        attendancePerformance,
        parentAction: alert.parentAction,
        alertStatus: alert.alertType,
        reason: alert.reason || undefined
      };
    });

    // Split into responded and awaiting
    const responded = processedAlerts.filter(
      alert => alert.parentAction === 'RESPONDED'
    );
    const awaiting = processedAlerts.filter(
      alert => alert.parentAction === 'NO_RESPONSE'
    );

    return NextResponse.json({ 
      data: {
        responded,
        awaiting
      }
    });
  } catch (error) {
    console.error("[ALERTS_GET]", error);
    return NextResponse.json(
      { error: "Failed to fetch alerts" },
      { status: 500 }
    );
  }
}
```

[Continue with next module...]

### 6. Attendance Management
**Files**:
- **Actions**: `src/actions/attendance/`
  - `index.ts`
  - `schema.ts`
- **API Routes**: `src/app/api/kindergarten/[orgId]/dashboard/`
  - `route.ts`
  - `attendance/route.ts`
- **Hooks**: 
  - `useAttendanceStats.ts`
- **Types**:
  - `attendance.ts`

**Purpose**: Track and manage student attendance records, calculate attendance rates, and generate attendance-related alerts.

**Functionality**:
- Record daily student attendance
- Track attendance status (ON_TIME, LATE, ABSENT)
- Calculate attendance rates and statistics
- Generate attendance reports
- Monitor late arrivals and absences
- Integrate with alert system for attendance notifications

**Implementation**:

schema.ts:
```typescript
// @/actions/attendance/schema.ts
import { z } from "zod";

export const AttendanceSchema = z.object({
    studentId: z.string().min(1, "Student ID is required"),
    date: z.date(),
    status: z.enum(["PENDING", "ON_TIME", "LATE", "ABSENT"]),
    timeRecorded: z.date()
});

export type AttendanceSchemaType = z.infer<typeof AttendanceSchema>;
```

index.ts:
```typescript
// src/actions/attendance/index.ts
"use server";

import { db } from "@/lib/db";
import { AttendanceSchema, AttendanceSchemaType } from "./schema";
import { createSafeAction } from "@/lib/create-safe-action";

const handler = async (data: AttendanceSchemaType) => {
    try {
        const attendance = await db.attendance.create({
            data: {
                studentId: data.studentId,
                date: data.date,
                status: data.status,
                timeRecorded: data.timeRecorded
            }
        });

        return { data: attendance };
    } catch (error) {
        return { error: "Failed to create attendance record." };
    }
};

export const createAttendance = createSafeAction(AttendanceSchema, handler);

// Get attendance statistics for the past 6 months
export const getAttendanceStats = async (kindergartenId: string) => {
  try {
    const today = new Date();
    const sixMonthsAgo = subMonths(today, 6);

    // Get all attendance records for the past 6 months
    const attendanceRecords = await db.attendance.findMany({
      where: {
        student: {
          class: {
            kindergartenId
          }
        },
        date: {
          gte: new Date(new Date().setDate(new Date().getDate() - 180)) // Last 6 months
        }
      }
    });

    // Group by month and calculate attendance rate
    const monthlyStats = Array.from({ length: 6 }, (_, i) => {
      const monthDate = subMonths(today, i);
      const monthStart = startOfMonth(monthDate);
      const monthEnd = endOfMonth(monthDate);

      const monthRecords = attendanceRecords.filter(record => 
        record.date >= monthStart && record.date <= monthEnd
      );

      const totalRecords = monthRecords.length;
      const presentRecords = monthRecords.filter(record => 
        record.status === "ON_TIME" || record.status === "LATE"
      ).length;

      return {
        date: monthStart,
        attendanceRate: totalRecords > 0 ? presentRecords / totalRecords : 0
      };
    }).reverse(); // Most recent last

    return { data: monthlyStats };
  } catch (error) {
    console.error("[GET_ATTENDANCE_STATS]", error);
    return { error: "Failed to fetch attendance stats" };
  }
};
```

useAttendanceStats.ts:
```typescript
// hooks/useAttendanceStats.ts
import { useQuery } from "@tanstack/react-query";

export function useAttendanceStats(kindergartenId: string) {
    return useQuery({
      queryKey: ['dashboard', 'attendance', kindergartenId],
      queryFn: async () => {
        const response = await fetch(`/api/kindergarten/${kindergartenId}/dashboard/attendance`);
        if (!response.ok) throw new Error('Failed to fetch attendance stats');
        return response.json();
      }
    });
}
```

attendance-table.tsx:
```typescript
// src/app/kindergarten/[orgId]/student-list/[studentId]/_components/attendance-table.tsx
"use client";
import { format } from "date-fns";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";

interface AttendanceTableProps {
  attendance: any[]; // Type this properly
}

export function AttendanceTable({ attendance }: AttendanceTableProps) {
  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Date</TableHead>
          <TableHead>Status</TableHead>
          <TableHead>Time Recorded</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {attendance.map((record) => (
          <TableRow key={record.id}>
            <TableCell>{format(record.date, "PPP")}</TableCell>
            <TableCell>
              <Badge
                variant={
                  record.status === "ON_TIME"
                    ? "positive"
                    : record.status === "LATE"
                    ? "warning"
                    : "negative"
                }
              >
                {record.status}
              </Badge>
            </TableCell>
            <TableCell>{format(record.timeRecorded, "p")}</TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}
```

[Continue with next module...]

### 8. Profile Management
**Files**:
- **Actions**: `src/actions/admin/`
  - `index.ts`
  - `schema.ts`
- **API Routes**: `src/app/api/auth/`
  - `profile/route.ts`
- **Hooks**: 
  - `useProfile.ts`
  - `use-action.ts`
- **Types**:
  - `admin.ts`

**Purpose**: Manage user profile information and account settings for both administrators and parents.

**Functionality**:
- View and update profile information
- Manage account settings
- Handle kindergarten association
- Leave kindergarten functionality for admins
- View role and permissions

**Implementation**:

profile/route.ts:
```typescript
// app/api/auth/profile/route.ts
import { db } from "@/lib/db";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    const { firebaseId } = await req.json();

    if (!firebaseId) {
      return NextResponse.json(
        { error: "Firebase ID is required" },
        { status: 400 }
      );
    }

    const admin = await db.admin.findUnique({
      where: { firebaseId },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        kindergartenId: true,
      },
    });

    if (!admin) {
      return NextResponse.json(
        { error: "Admin not found" },
        { status: 404 }
      );
    }

    return NextResponse.json(admin);
  } catch (error) {
    console.error("[PROFILE_ERROR]", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

admin/index.ts:
```typescript
// actions/admin/index.ts
"use server"

import { db } from "@/lib/db";
import { z } from "zod";
import { createSafeAction } from "@/lib/create-safe-action";

const LeaveKindergartenSchema = z.object({
  adminId: z.string()
});

const leaveKindergartenHandler = async (data: z.infer<typeof LeaveKindergartenSchema>) => {
  try {
    // Check if admin exists
    const admin = await db.admin.findUnique({
      where: { id: data.adminId }
    });

    if (!admin) {
      return { error: "Admin not found" };
    }

    // Remove kindergarten association
    const updatedAdmin = await db.admin.update({
      where: { id: data.adminId },
      data: {
        kindergartenId: null,
        role: "ADMIN" // Reset role to default
      }
    });

    return { data: updatedAdmin };
  } catch (error) {
    return { error: "Failed to leave kindergarten" };
  }
};

export const leaveKindergarten = createSafeAction(
  LeaveKindergartenSchema,
  leaveKindergartenHandler
);
```

use-action.ts:
```typescript
// hooks/use-action.ts
import { useState, useCallback } from 'react';
import { ActionState, FieldErrors } from '@/lib/create-safe-action';

type Action<TInput, TOutput> = (data: TInput) => Promise<ActionState<TInput, TOutput>>;

interface UseActionOptions<TOutput> {
    onSuccess?: (data: TOutput) => void;
    onError?: (error: string) => void;
    onComplete?: () => void;
}

export const useAction = <TInput, TOutput>(
    action: Action<TInput, TOutput>,
    options: UseActionOptions<TOutput> = {}
) => {
    const [fieldErrors, setFieldErrors] = useState<FieldErrors<TInput> | undefined>(undefined);
    const [error, setError] = useState<string | undefined>(undefined);
    const [data, setData] = useState<TOutput | undefined>(undefined);
    const [isLoading, setIsLoading] = useState<boolean>(false);

    const execute = useCallback(
        async (input: TInput) => {
            setIsLoading(true);
            try {
                const result = await action(input);
                if (!result) return;

                if (result.error) {
                    setError(result.error);
                    options.onError?.(result.error);
                }

                if (result.data) {
                    setData(result.data);
                    options.onSuccess?.(result.data);
                }

                setFieldErrors(result.fieldErrors);
            } finally {
                setIsLoading(false);
                options.onComplete?.();
            }
        },
        [action, options]
    );

    return {
        execute,
        fieldErrors,
        error,
        data,
        isLoading,
    };
};
```

### Report Generation
**Files**:
- **Actions**: `src/actions/report/`
  - `index.ts`
  - `schema.ts`
- **API Routes**: `src/app/api/kindergarten/[orgId]/report/`
  - `route.ts`
- **Hooks**: 
  - `useReport.ts`
  - `useReportGeneration.ts`
- **Types**:
  - `report.ts`

**Purpose**: Generate comprehensive reports on student attendance, performance, and class statistics.

**Functionality**:
- Filter students by class and search criteria
- Generate printable reports with student information
- Display attendance statistics and performance metrics
- Include parent contact information
- Support report exports

**Implementation**:

types/report.ts:
```typescript
// types/report.ts
export interface StudentReport {
  id: string;
  name: string;
  class: string;
  age: number;
  attendance: string;
  lateCount: number;
  absentCount: number;
  parentName: string;
  parentPhone: string;
}

export interface ClassReport {
  id: string;
  name: string;
  students: StudentReport[];
}

export interface ReportFilters {
  classId?: string;
  searchQuery?: string;
}
```

Report Generation Page:
```typescript
// src/app/(system)/kindergarten/[orgId]/report/page.tsx
"use client";

export default function ReportPage() {
  const [selectedClass, setSelectedClass] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");

  const filteredStudents = DUMMY_STUDENTS.filter((student) => {
    const matchesClass = !selectedClass || student.class === selectedClass;
    const matchesSearch =
      student.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      student.parentName.toLowerCase().includes(searchQuery.toLowerCase());
    return matchesClass && matchesSearch;
  });

  const handlePrint = () => {
    window.print();
  };

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Student Reports</h1>
        <Button onClick={handlePrint} className="print:hidden">
          <Printer className="h-4 w-4 mr-2" />
          Print Report
        </Button>
      </div>

      <div className="flex gap-4 print:hidden">
        <div className="w-[200px]">
          <Select
            value={selectedClass || undefined}
            onValueChange={setSelectedClass}
          >
            <SelectTrigger>
              <SelectValue placeholder="Filter by class" />
            </SelectTrigger>
            <SelectContent>
              {DUMMY_CLASSES.map((cls) => (
                <SelectItem key={cls.id} value={cls.name}>
                  {cls.name}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
        <div className="flex-1 max-w-sm">
          <div className="relative">
            <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search by student or parent name"
              className="pl-8"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
          </div>
        </div>
      </div>

      <Card className="mt-6">
        <CardHeader className="pb-2">
          <CardTitle>Student Information</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="rounded-md border">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Student Name
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Class
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Age
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Attendance
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Late Count
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Absent Count
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Parent Info
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {filteredStudents.map((student) => (
                  <TableRow key={student.id}>
                    <TableCell>{student.name}</TableCell>
                    <TableCell>{student.class}</TableCell>
                    <TableCell>{student.age} years</TableCell>
                    <TableCell>{student.attendance}</TableCell>
                    <TableCell>{student.lateCount}</TableCell>
                    <TableCell>{student.absentCount}</TableCell>
                    <TableCell>
                      <div>
                        <div className="font-medium">{student.parentName}</div>
                        <div className="text-sm text-gray-500">
                          {student.parentPhone}
                        </div>
                      </div>
                    </TableCell>
                  </TableRow>
                ))}
              </tbody>
            </table>
          </div>
        </CardContent>
      </Card>

      <style jsx global>{`
        @media print {
          body * {
            visibility: hidden;
          }
          .print\\:hidden {
            display: none;
          }
          #print-content,
          #print-content * {
            visibility: visible;
          }
          #print-content {
            position: absolute;
            left: 0;
            top: 0;
          }
        }
      `}</style>
    </div>
  );
}
```